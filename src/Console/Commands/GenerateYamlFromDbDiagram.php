<?php

namespace NahidFerdous\LaravelModuleGenerator\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Str;
use Symfony\Component\Yaml\Yaml;

class GenerateYamlFromDbDiagram extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'dbdiagram:import
                             {--file= : Path to the DBML file}
                             {--output= : Path to the output YAML file}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Generate YAML schema from dbdiagram.io DBML syntax';

    /**
     * Execute the console command.
     *
     * @return int
     */
    public function handle()
    {
        // Get config values
        $config = config('module-generator');

        // Resolve options with config fallbacks
        $dbmlFilePath = $this->option('file') ?: $config['dbdiagram']['output_path'];
        $defaultOutputPath = $config['models_path'];

        $this->info("Reading DBML schema from: $dbmlFilePath");

        if (! file_exists($dbmlFilePath)) {
            $this->error("File not found: $dbmlFilePath");

            return Command::FAILURE;
        }

        // Check if an output file exists
        $outputFilePath = $this->option('output');
        if (! $outputFilePath) {
            if (file_exists($defaultOutputPath)) {
                $choice = $this->choice(
                    "File already exists at: $defaultOutputPath\nWhat would you like to do?",
                    [
                        'override' => 'Override the existing file',
                        'new' => 'Create a new file with a different name',
                        'cancel' => 'Cancel the operation',
                    ],
                    'cancel'
                );

                if ($choice === 'cancel') {
                    $this->info('Operation cancelled.');

                    return Command::SUCCESS;
                }

                if ($choice === 'new') {
                    $outputFilePath = $this->ask('Enter the new filename (without path)', 'models-new.yaml');
                    $outputFilePath = dirname($defaultOutputPath).'/'.$outputFilePath;
                } else {
                    $outputFilePath = $defaultOutputPath;
                }
            } else {
                $outputFilePath = $defaultOutputPath;
            }
        }

        // Ensure output directory exists
        $outputDir = dirname($outputFilePath);
        if (! is_dir($outputDir) && ! mkdir($outputDir, 0755, true) && ! is_dir($outputDir)) {
            throw new \RuntimeException(sprintf('Directory "%s" was not created', $outputDir));
        }

        $this->info("Output will be saved to: {$outputFilePath}");

        $dbmlContent = file_get_contents($dbmlFilePath);
        $schema = $this->parseDbml($dbmlContent);

        // Remove empty relations from schema
        foreach ($schema as &$model) {
            if (empty($model['relations'])) {
                unset($model['relations']);
            }
        }

        // Convert to YAML
        $yamlOutput = Yaml::dump($schema, 10, 2);

        // Add blank lines between models for better readability
        $yamlOutput = $this->formatYamlWithGaps($yamlOutput);

        // Remove unnecessary quotes around field definitions with defaults
        $yamlOutput = $this->removeQuotesFromDefaults($yamlOutput);

        file_put_contents($outputFilePath, "# This file is auto-generated by LaravelModuleGenerator\n# Multi-Vendor E-Commerce Platform Configuration\n# Flexible structure supports both single-vendor and multi-vendor modes\n\n".$yamlOutput);
        $this->info('ðŸŽ¯ YAML schema generated successfully at: '.$outputFilePath);
        $this->info('ðŸ“Š Generated models for '.count($schema).' tables');

        return Command::SUCCESS;
    }

    /**
     * Parse DBML content and convert to a schema array
     */
    protected function parseDbml(string $dbmlContent): array
    {
        $schema = [];
        $tables = [];
        $relationships = [];

        // Extract table definitions
        preg_match_all('/Table\s+(\w+)\s*\{([^}]+)\}/i', $dbmlContent, $matches);

        foreach ($matches[1] as $index => $tableName) {
            $tableBody = $matches[2][$index];
            $tables[$tableName] = $this->parseTableBody($tableBody);
        }

        // Extract relationships - handle both > and < operators
        preg_match_all('/Ref\s*\w*:?\s*(\w+)\.(\w+)\s*([><])\s*(\w+)\.(\w+)/i', $dbmlContent, $refMatches);

        foreach ($refMatches[1] as $index => $fromTable) {
            $fromColumn = $refMatches[2][$index];
            $operator = $refMatches[3][$index];
            $toTable = $refMatches[4][$index];
            $toColumn = $refMatches[5][$index];

            // If operator is <, swap the direction (A < B means B > A)
            if ($operator === '<') {
                [$fromTable, $toTable] = [$toTable, $fromTable];
                [$fromColumn, $toColumn] = [$toColumn, $fromColumn];
            }

            $relationships[] = [
                'from_table' => $fromTable,
                'from_column' => $fromColumn,
                'to_table' => $toTable,
                'to_column' => $toColumn,
            ];
        }

        // Build schema with relationships
        foreach ($tables as $tableName => $fields) {
            $modelName = $this->tableNameToModelName($tableName);

            // Check if model has soft deletes
            $hasSoftDeletes = isset($fields['deleted_at']);

            // Build a basic model structure
            $schema[$modelName] = [
                'generate' => 'all',
                'fields' => [],
                'relations' => [],
            ];

            // Add primaryKey if not 'id' (in this context, we assume 'id' is default)
            // We could detect UUIDs or other primary keys from DBML if needed

            // Add softDeletes detection - already handled by deleted_at field presence

            // Add fields (exclude id, created_at, updated_at)
            foreach ($fields as $fieldName => $fieldInfo) {
                if (! in_array($fieldName, ['id', 'created_at', 'updated_at'])) {
                    // Find relationship info for this field
                    $relationshipInfo = null;
                    foreach ($relationships as $rel) {
                        if ($rel['from_table'] === $tableName && $rel['from_column'] === $fieldName) {
                            $relationshipInfo = $rel;
                            break;
                        }
                    }
                    $schema[$modelName]['fields'][$fieldName] = $this->reconstructFieldDefinition($fieldName, $fieldInfo, $relationshipInfo);
                }
            }

            // Add relationships
            $modelTableName = Str::snake(Str::pluralStudly($modelName));
            foreach ($relationships as $rel) {
                if ($rel['from_table'] === $modelTableName) {
                    $this->addRelationship($schema, $modelName, $rel, $tables);
                }
            }
        }

        return $schema;
    }

    /**
     * Parse table body to extract fields
     */
    protected function parseTableBody(string $body): array
    {
        $fields = [];
        $lines = array_filter(array_map('trim', explode("\n", $body)));

        foreach ($lines as $line) {
            if (empty($line)) {
                continue;
            }

            // Parse field definition
            // Format: fieldName type [optional: "nullable"] [optional: "primary key"] [optional: "default: value"]
            if (preg_match('/^(\w+)\s+(\w+)(?:\s*\[(.*?)\])?/', $line, $matches)) {
                $fieldName = $matches[1];
                $fieldType = $matches[2];
                $notes = isset($matches[3]) ? $matches[3] : '';

                $fields[$fieldName] = [
                    'type' => $fieldType,
                    'nullable' => str_contains($notes, 'nullable'),
                    'primary_key' => str_contains($notes, 'primary key'),
                    'default' => $this->extractDefaultValue($notes),
                ];
            }
        }

        return $fields;
    }

    /**
     * Extract default value from DBML notes
     */
    protected function extractDefaultValue(string $notes): ?string
    {
        // Match default: "value" or default: value (without quotes)
        if (preg_match('/default:\s*"([^"]*)"/', $notes, $matches)) {
            return $matches[1];
        }

        if (preg_match('/default:\s*([^\s\]]+)/', $notes, $matches)) {
            return $matches[1];
        }

        return null;
    }

    /**
     * Reconstruct field definition string from parsed field info
     */
    protected function reconstructFieldDefinition(string $fieldName, array $fieldInfo, ?array $relationshipInfo = null): string
    {
        $type = $fieldInfo['type'] ?? 'string';

        // Map DBML types to Laravel migration types
        $type = $this->mapDbmlTypeToLaravelType($type, $fieldName);

        // If we have relationship info, this is a foreign key - append the referenced table
        if ($relationshipInfo) {
            $referencedTable = $relationshipInfo['to_table'];
            $referencedModel = Str::singular($referencedTable);
            $type = 'foreignId'.':'.$referencedModel;
        }

        // Add modifiers
        $modifiers = [];
        if ($fieldInfo['nullable'] ?? false) {
            $modifiers[] = 'nullable';
        }

        // Add a default value if present
        if (! empty($fieldInfo['default'])) {
            $defaultValue = $fieldInfo['default'];
            // Format: default value (with space, no colon, no quotes)
            $modifiers[] = 'default '.$defaultValue;
        }

        if (! empty($modifiers)) {
            return $type.':'.implode(':', $modifiers);
        }

        return $type;
    }

    /**
     * Map DBML types to Laravel migration types
     */
    protected function mapDbmlTypeToLaravelType(string $dbmlType, string $fieldName): string
    {
        return match (strtolower($dbmlType)) {
            'integer' => $this->detectForeignKeyType($fieldName) ? 'foreignId' : 'integer',
            'string' => 'string',
            'text' => 'text',
            'boolean' => 'boolean',
            'double' => 'double',
            'decimal' => 'decimal',
            'date' => 'date',
            'datetime' => 'dateTime',
            'timestamp' => 'timestamp',
            default => 'string',
        };
    }

    /**
     * Detect if a field is a foreign key
     */
    protected function detectForeignKeyType(string $fieldName): bool
    {
        return str_ends_with($fieldName, '_id') && $fieldName !== 'id';
    }

    /**
     * Add relationship to schema
     */
    protected function addRelationship(array &$schema, string $modelName, array $relationship, array $tables): void
    {
        $fromColumn = $relationship['from_column'];
        $toTable = $relationship['to_table'];
        $toTableName = Str::studly(Str::singular($toTable));

        // Determine relationship name and type
        $relationshipName = $this->getRelationshipName($fromColumn);

        // Skip relationships that are already in fields
        if (in_array($fromColumn, array_keys($schema[$modelName]['fields'] ?? []))) {
            // Check if it's a special relationship like creator or updater
            if ($relationshipName === 'creator' || $relationshipName === 'updater') {
                $schema[$modelName]['relations'][$relationshipName] = [
                    'type' => 'belongsTo',
                    'model' => $toTableName,
                ];
            } else {
                // Add belongsTo relationship for foreign keys
                $schema[$modelName]['relations'][$relationshipName] = [
                    'type' => 'belongsTo',
                    'model' => $toTableName,
                ];
            }
        }
    }

    /**
     * Get relationship name from column name
     */
    protected function getRelationshipName(string $columnName): string
    {
        // Handle special cases
        if ($columnName === 'created_by') {
            return 'creator';
        }
        if ($columnName === 'updated_by') {
            return 'updater';
        }
        if ($columnName === 'verified_by_id') {
            return 'verifiedBy';
        }
        if ($columnName === 'changed_by_id') {
            return 'changedBy';
        }

        // Remove _id suffix and convert to camelCase
        $name = str_replace('_id', '', $columnName);

        return Str::camel($name);
    }

    /**
     * Convert table name to model name
     */
    protected function tableNameToModelName(string $tableName): string
    {
        return Str::studly(Str::singular($tableName));
    }

    /**
     * Remove unnecessary quotes around field definitions with defaults
     */
    protected function removeQuotesFromDefaults(string $yamlContent): string
    {
        // Remove quotes from any field definition that contains colons
        // Match: field: 'value:something' -> field: value:something
        $yamlContent = preg_replace(
            "/:\s+'([^']*:[^']*)'$/m",
            ': $1',
            $yamlContent
        );

        return $yamlContent;
    }

    /**
     * Remove empty relations sections from YAML
     */
    protected function removeEmptyRelations(string $yamlContent): string
    {
        // Remove lines that have "relations: {  }" (empty relations)
        // This includes the indentation and the entire line
        $yamlContent = preg_replace(
            "/\s+relations:\s*\{\s*\}\s*\n?/m",
            '',
            $yamlContent
        );

        return $yamlContent;
    }

    /**
     * Format YAML output with blank lines between models
     */
    protected function formatYamlWithGaps(string $yamlContent): string
    {
        $lines = explode("\n", $yamlContent);
        $result = [];

        foreach ($lines as $index => $line) {
            $result[] = $line;

            // If this line is not empty and starts with indentation, it means we're inside a model
            // If the next line is not empty, doesn't start with indentation, and ends with:
            // it means we're starting a new model - add a gap before it
            if ($line !== '' && str_starts_with($line, ' ')) {
                // We're in indented content
                $nextLine = $lines[$index + 1] ?? null;

                if ($nextLine !== null && $nextLine !== '' && ! str_starts_with($nextLine, ' ') && str_ends_with($nextLine, ':')) {
                    // The next line is a new top-level model, add a blank line
                    $result[] = '';
                }
            }
        }

        return implode("\n", $result);
    }
}
