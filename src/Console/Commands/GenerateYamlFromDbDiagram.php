<?php

namespace NahidFerdous\LaravelModuleGenerator\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Str;
use Symfony\Component\Yaml\Yaml;

class GenerateYamlFromDbDiagram extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'dbdiagram:import
                             {--file= : Path to the DBML file}
                             {--output= : Path to the output YAML file}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Generate YAML schema from dbdiagram.io DBML syntax';

    /**
     * Execute the console command.
     *
     * @return int
     */
    public function handle()
    {
        // Get config values
        $config = config('module-generator');

        // Resolve options with config fallbacks
        $dbmlFilePath = $this->option('file') ?: $config['dbdiagram']['output_path'];
        $defaultOutputPath = $config['models_path'];

        $this->info("Reading DBML schema from: $dbmlFilePath");

        if (! file_exists($dbmlFilePath)) {
            $this->error("File not found: $dbmlFilePath");

            return Command::FAILURE;
        }

        // Check if an output file exists
        $outputFilePath = $this->option('output');
        if (! $outputFilePath) {
            if (file_exists($defaultOutputPath)) {
                $choice = $this->choice(
                    "File already exists at: $defaultOutputPath\nWhat would you like to do?",
                    [
                        'override' => 'Override the existing file',
                        'new' => 'Create a new file with a different name',
                        'cancel' => 'Cancel the operation',
                    ],
                    'cancel'
                );

                if ($choice === 'cancel') {
                    $this->info('Operation cancelled.');

                    return Command::SUCCESS;
                }

                if ($choice === 'new') {
                    $outputFilePath = $this->ask('Enter the new filename (without path)', 'models-new.yaml');
                    $outputFilePath = dirname($defaultOutputPath).'/'.$outputFilePath;
                } else {
                    $outputFilePath = $defaultOutputPath;
                }
            } else {
                $outputFilePath = $defaultOutputPath;
            }
        }

        // Ensure output directory exists
        $outputDir = dirname($outputFilePath);
        if (! is_dir($outputDir) && ! mkdir($outputDir, 0755, true) && ! is_dir($outputDir)) {
            throw new \RuntimeException(sprintf('Directory "%s" was not created', $outputDir));
        }

        $this->info("Output will be saved to: {$outputFilePath}");

        $dbmlContent = file_get_contents($dbmlFilePath);
        $schema = $this->parseDbml($dbmlContent);

        // Remove empty relations and generate_except from schema
        foreach ($schema as &$model) {
            if (empty($model['relations'])) {
                unset($model['relations']);
            }
            if (empty($model['generate_except'])) {
                unset($model['generate_except']);
            }
        }

        // Convert to YAML
        $yamlOutput = Yaml::dump($schema, 10, 2);

        // Add blank lines between models for better readability
        $yamlOutput = $this->formatYamlWithGaps($yamlOutput);

        // Remove unnecessary quotes around field definitions
        $yamlOutput = $this->removeQuotesFromFields($yamlOutput);

        file_put_contents($outputFilePath, "# This file is auto-generated by LaravelModuleGenerator\n# Multi-Vendor E-Commerce Platform Configuration\n# Flexible structure supports both single-vendor and multi-vendor modes\n\n".$yamlOutput);
        $this->info('ðŸŽ¯ YAML schema generated successfully at: '.$outputFilePath);
        $this->info('ðŸ“Š Generated models for '.count($schema).' tables');

        return Command::SUCCESS;
    }

    /**
     * Parse DBML content and convert to a schema array
     */
    protected function parseDbml(string $dbmlContent): array
    {
        $schema = [];
        $tables = [];
        $relationships = [];

        // Extract table definitions
        preg_match_all('/Table\s+(\w+)\s*\{([^}]+)\}/i', $dbmlContent, $matches);

        foreach ($matches[1] as $index => $tableName) {
            $tableBody = $matches[2][$index];
            $tables[$tableName] = $this->parseTableBody($tableBody);
        }

        // Extract relationships - handle both > and < operators
        preg_match_all('/Ref\s*\w*:?\s*(\w+)\.(\w+)\s*([><])\s*(\w+)\.(\w+)/i', $dbmlContent, $refMatches);

        foreach ($refMatches[1] as $index => $fromTable) {
            $fromColumn = $refMatches[2][$index];
            $operator = $refMatches[3][$index];
            $toTable = $refMatches[4][$index];
            $toColumn = $refMatches[5][$index];

            // If operator is <, swap the direction (A < B means B > A)
            if ($operator === '<') {
                [$fromTable, $toTable] = [$toTable, $fromTable];
                [$fromColumn, $toColumn] = [$toColumn, $fromColumn];
            }

            $relationships[] = [
                'from_table' => $fromTable,
                'from_column' => $fromColumn,
                'to_table' => $toTable,
                'to_column' => $toColumn,
            ];
        }

        // Build schema with relationships
        foreach ($tables as $tableName => $fields) {
            $modelName = $this->tableNameToModelName($tableName);

            // Build a basic model structure
            $schema[$modelName] = [
                'generate_except' => '',
                'fields' => [],
                'relations' => [
                    'belongsTo' => [],
                    'hasMany' => [],
                    'hasOne' => [],
                ],
            ];

            // Add fields (exclude id, created_at, updated_at)
            foreach ($fields as $fieldName => $fieldInfo) {
                if (! in_array($fieldName, ['id', 'created_at', 'updated_at'])) {
                    // Find relationship info for this field
                    $relationshipInfo = null;
                    foreach ($relationships as $rel) {
                        if ($rel['from_table'] === $tableName && $rel['from_column'] === $fieldName) {
                            $relationshipInfo = $rel;
                            break;
                        }
                    }
                    $schema[$modelName]['fields'][$fieldName] = $this->reconstructFieldDefinition($fieldName, $fieldInfo, $relationshipInfo);
                }
            }

            // Add relationships
            $modelTableName = Str::snake(Str::pluralStudly($modelName));
            foreach ($relationships as $rel) {
                if ($rel['from_table'] === $modelTableName) {
                    $this->addBelongsToRelationship($schema, $modelName, $rel);
                }
            }

            // Add inverse relationships (hasMany)
            foreach ($relationships as $rel) {
                if ($rel['to_table'] === $modelTableName) {
                    $this->addHasManyRelationship($schema, $modelName, $rel, $tables);
                }
            }

            // Convert relations to compact format
            $schema[$modelName]['relations'] = $this->compactRelations($schema[$modelName]['relations']);

            // Remove empty relations
            if (empty($schema[$modelName]['relations'])) {
                unset($schema[$modelName]['relations']);
            }
        }

        return $schema;
    }

    /**
     * Parse table body to extract fields
     */
    protected function parseTableBody(string $body): array
    {
        $fields = [];
        $lines = array_filter(array_map('trim', explode("\n", $body)));

        foreach ($lines as $line) {
            if (empty($line)) {
                continue;
            }

            // Parse field definition
            // Format: fieldName type [optional: "nullable"] [optional: "primary key"] [optional: "default: value"]
            if (preg_match('/^(\w+)\s+(\w+)(?:\s*\[(.*?)\])?/', $line, $matches)) {
                $fieldName = $matches[1];
                $fieldType = $matches[2];
                $notes = isset($matches[3]) ? $matches[3] : '';

                $fields[$fieldName] = [
                    'type' => $fieldType,
                    'nullable' => str_contains($notes, 'nullable'),
                    'unique' => str_contains($notes, 'unique'),
                    'primary_key' => str_contains($notes, 'primary key'),
                    'default' => $this->extractDefaultValue($notes),
                ];
            }
        }

        return $fields;
    }

    /**
     * Extract default value from DBML notes
     */
    protected function extractDefaultValue(string $notes): ?string
    {
        // Match default: "value" or default: value (without quotes)
        if (preg_match('/default:\s*"([^"]*)"/', $notes, $matches)) {
            return $matches[1];
        }

        if (preg_match('/default:\s*([^\s\]]+)/', $notes, $matches)) {
            return $matches[1];
        }

        return null;
    }

    /**
     * Reconstruct field definition string from parsed field info
     */
    protected function reconstructFieldDefinition(string $fieldName, array $fieldInfo, ?array $relationshipInfo = null): string
    {
        $type = $fieldInfo['type'] ?? 'string';

        // Map DBML types to Laravel migration types
        $type = $this->mapDbmlTypeToLaravelType($type, $fieldName);

        $parts = [$type];

        // If we have relationship info, this is a foreign key - append the referenced table
        if ($relationshipInfo) {
            $referencedTable = $relationshipInfo['to_table'];
            $parts[] = $referencedTable;
        }

        // Add modifiers
        if ($fieldInfo['unique'] ?? false) {
            $parts[] = 'unique';
        }

        if ($fieldInfo['nullable'] ?? false) {
            $parts[] = 'nullable';
        }

        // Add a default value if present
        if (! empty($fieldInfo['default'])) {
            $defaultValue = $fieldInfo['default'];
            $parts[] = 'default '.$defaultValue;
        }

        return implode(':', $parts);
    }

    /**
     * Map DBML types to Laravel migration types
     */
    protected function mapDbmlTypeToLaravelType(string $dbmlType, string $fieldName): string
    {
        return match (strtolower($dbmlType)) {
            'integer' => $this->detectForeignKeyType($fieldName) ? 'foreignId' : 'integer',
            'string' => 'string',
            'text' => 'text',
            'boolean' => 'boolean',
            'double' => 'double',
            'decimal' => 'decimal',
            'date' => 'date',
            'datetime' => 'dateTime',
            'timestamp' => 'timestamp',
            default => 'string',
        };
    }

    /**
     * Detect if a field is a foreign key
     */
    protected function detectForeignKeyType(string $fieldName): bool
    {
        return str_ends_with($fieldName, '_id') && $fieldName !== 'id';
    }

    /**
     * Add belongsTo relationship to schema
     */
    protected function addBelongsToRelationship(array &$schema, string $modelName, array $relationship): void
    {
        $fromColumn = $relationship['from_column'];
        $toTable = $relationship['to_table'];
        $toModel = Str::studly(Str::singular($toTable));

        // Determine relationship name
        $relationshipName = $this->getRelationshipName($fromColumn);

        $schema[$modelName]['relations']['belongsTo'][] = [
            'model' => $toModel,
            'name' => $relationshipName,
        ];
    }

    /**
     * Add hasMany relationship to schema
     */
    protected function addHasManyRelationship(array &$schema, string $modelName, array $relationship, array $tables): void
    {
        $fromTable = $relationship['from_table'];
        $fromModel = Str::studly(Str::singular($fromTable));
        $fromColumn = $relationship['from_column'];

        // Determine relationship name (pluralize the foreign model)
        $relationshipName = $this->getHasManyRelationshipName($fromColumn, $fromModel);

        $schema[$modelName]['relations']['hasMany'][] = [
            'model' => $fromModel,
            'name' => $relationshipName,
        ];
    }

    /**
     * Get belongsTo relationship name from column name
     */
    protected function getRelationshipName(string $columnName): string
    {
        // Handle special cases
        $specialCases = [
            'created_by' => 'creator',
            'updated_by' => 'updater',
            //            'verified_by_id' => 'verifiedBy',
            //            'changed_by_id' => 'changedBy',
        ];

        if (isset($specialCases[$columnName])) {
            return $specialCases[$columnName];
        }

        // Remove _id suffix and convert to camelCase
        $name = str_replace('_id', '', $columnName);

        return Str::camel($name);
    }

    /**
     * Get hasMany relationship name
     */
    protected function getHasManyRelationshipName(string $columnName, string $relatedModel): string
    {
        // Handle self-referencing relationships
        $relationName = $this->getRelationshipName($columnName);

        if ($relationName === 'parent') {
            return 'children';
        }

        // Default: pluralize the related model name
        return Str::camel(Str::plural($relatedModel));
    }

    /**
     * Convert relations array to compact format
     * From: ['belongsTo' => [['model' => 'User', 'name' => 'creator'], ...]]
     * To: ['belongsTo' => 'User:creator, User:updater']
     */
    protected function compactRelations(array $relations): array
    {
        $compacted = [];

        foreach ($relations as $type => $relationList) {
            if (empty($relationList)) {
                continue;
            }

            $formatted = [];
            foreach ($relationList as $relation) {
                $formatted[] = $relation['model'].':'.$relation['name'];
            }

            if (! empty($formatted)) {
                $compacted[$type] = implode(', ', $formatted);
            }
        }

        return $compacted;
    }

    /**
     * Convert table name to model name
     */
    protected function tableNameToModelName(string $tableName): string
    {
        return Str::studly(Str::singular($tableName));
    }

    /**
     * Remove unnecessary quotes around field definitions
     */
    protected function removeQuotesFromFields(string $yamlContent): string
    {
        // Remove quotes from field definitions that contain colons
        $yamlContent = preg_replace(
            "/^(\s+\w+):\s+'([^']*:[^']*)'$/m",
            '$1: $2',
            $yamlContent
        );

        // Remove quotes from relation definitions
        $yamlContent = preg_replace(
            "/^(\s+(?:belongsTo|hasMany|hasOne)):\s+'([^']*)'$/m",
            '$1: $2',
            $yamlContent
        );

        return $yamlContent;
    }

    /**
     * Format YAML output with blank lines between models
     */
    protected function formatYamlWithGaps(string $yamlContent): string
    {
        $lines = explode("\n", $yamlContent);
        $result = [];

        foreach ($lines as $index => $line) {
            $result[] = $line;

            // If this line is not empty and starts with indentation, it means we're inside a model
            // If the next line is not empty, doesn't start with indentation, and ends with:
            // it means we're starting a new model - add a gap before it
            if ($line !== '' && str_starts_with($line, ' ')) {
                // We're in indented content
                $nextLine = $lines[$index + 1] ?? null;

                if ($nextLine !== null && $nextLine !== '' && ! str_starts_with($nextLine, ' ') && str_ends_with($nextLine, ':')) {
                    // The next line is a new top-level model, add a blank line
                    $result[] = '';
                }
            }
        }

        return implode("\n", $result);
    }
}
